{{#withSeparateModelsAndApi}}
  {{#x-ts-has-models}}
import { {{{x-ts-all-models}}} } from './';
  {{/x-ts-has-models}}

{{/withSeparateModelsAndApi}}
{{#models}}
{{#usesDiscriminator}}
  {{#model}}
class {{classname}}TypeTransformer {
  static toJson(val: {{classname}}): any {

    switch(val['{{{discriminator.propertyName}}}']) {
      {{#discriminator.mappedModels}}
      case '{{{mappingName}}}':
        return ObjectSerializer.serialize(val, '{{{modelName}}}');
      {{/discriminator.mappedModels}}
  {{#oneOf}}
      case '{{{.}}}':
        return ObjectSerializer.serialize(val, '{{{.}}}');
  {{/oneOf}}
      default:
        return val;
    }
  }

  static fromJson(__val: any): {{classname}} {
    switch(__val['{{{discriminator.propertyBaseName}}}']) {
{{#discriminator.mappedModels}}
        case '{{{mappingName}}}':
          return ObjectSerializer.deserialize(__val, '{{{modelName}}}');
{{/discriminator.mappedModels}}
      {{#oneOf}}
        case '{{{.}}}':
          return ObjectSerializer.deserialize(__val, '{{{.}}}');
      {{/oneOf}}
      default:
        return __val;
    }
  }
}
    {{/model}}
{{/usesDiscriminator}}
{{^usesDiscriminator}}
  {{#model}}

class {{classname}}TypeTransformer {
{{#additionalPropertiesType}}
  private static otherProperties = [{{#vars}}'{{{name}}}', {{/vars}}];
{{/additionalPropertiesType}}
  static toJson(__val: {{classname}}): any {
{{#isEnum}}
    return __val?.toString();
{{/isEnum}}
{{^isEnum}}
    const __data: any = {};
    {{>enhancedModelInnerToJson}}
    return __data;
{{/isEnum}}
  }

  // expect this to be a decoded value
  static fromJson(__val: any): {{classname}} {
{{#isEnum}}
    if (__val === null || __val === undefined) return undefined;
    switch (__val.toString()) {
    {{#allowableValues}}
      {{#enumVars}}
        case {{{value}}}:
          return {{classname}}.{{{name}}};
      {{/enumVars}}
    {{/allowableValues}}
    }

    return undefined;
{{/isEnum}}
{{^isEnum}}
    const __init: any = {
      {{>enhancedModelInnerFromJson}}
    };
    {{>enhancedModelInnerFromJsonProps}}
    {{#additionalPropertiesType}}
    for(let prop in __val) {
      if ({{classname}}TypeTransformer.otherProperties.indexOf(prop) === -1 && __val.hasOwnProperty(prop)) {
        __init[prop] = {{#vendorExtensions.x-ts-optimize}}__val[prop];{{/vendorExtensions.x-ts-optimize}}{{^vendorExtensions.x-ts-optimize}}ObjectSerializer.deserialize(__val[prop], '{{{additionalPropertiesType}}}');{{/vendorExtensions.x-ts-optimize}}
      }
    }
    {{/additionalPropertiesType}}
    return new {{classname}}(__init);
{{/isEnum}}
  }
}
  {{/model}}
{{/usesDiscriminator}}
{{/models}}


const _regList = new RegExp('^Array\\<(.*)\\>$');
const _regSet = new RegExp('^Set\\<(.*)\\>$');
const _regRecord = new RegExp('^Record\\<string,(.*)\\>$');
const _regMap = new RegExp('^Map\\<string,(.*)\\>$');

const _baseEncoder = (type: string, value: any) => value;
const _dateEncoder = (type: string, value: any) => {
  const val = value as Date;
  return `${val.getFullYear()}-${val.getMonth()}-${val.getDay()}`;
};

export declare type EncoderFunc = (type: string, value: any) => any;

export const serializers: Record<string, EncoderFunc> = {
  'string': _baseEncoder,
  'String': _baseEncoder,
  'email': _baseEncoder,
  'uuid': _baseEncoder,
  'int': _baseEncoder,
  'num': _baseEncoder,
  'number': _baseEncoder,
  'double': _baseEncoder,
  'float': _baseEncoder,
  'boolean': _baseEncoder,
  'object': _baseEncoder,
  'any': _baseEncoder,
  'Array<string>': _baseEncoder,
  'Array<String>': _baseEncoder,
  'Array<email>': _baseEncoder,
  'Array<int>': _baseEncoder,
  'Array<num>': _baseEncoder,
  'Array<number>': _baseEncoder,
  'Array<double>': _baseEncoder,
  'Array<float>': _baseEncoder,
  'Array<boolean>': _baseEncoder,
  'Array<object>': _baseEncoder,
  'Array<any>': _baseEncoder, 
  'Set<string>': _baseEncoder,
  'Set<String>': _baseEncoder,
  'Set<email>': _baseEncoder,
  'Set<int>': _baseEncoder,
  'Set<num>': _baseEncoder,
  'Set<number>': _baseEncoder,
  'Set<double>': _baseEncoder,
  'Set<float>': _baseEncoder,
  'Set<boolean>': _baseEncoder,
  'Set<object>': _baseEncoder,
  'Set<any>': _baseEncoder,
  'Date': _dateEncoder,
  'DateTime': (t, value) => (value as Date).toISOString(),
 {{#models}}
  {{#model}}
  '{{classname}}': (t, value) => {{classname}}TypeTransformer.toJson(value),
  {{/model}}
{{/models}}
};

const _stringDecoder = (type: string, value: any) => value.toString();
const _passthroughDecoder = (type: string, value: any) => value;
const _intDecoder = (type: string, value: any) => (value instanceof Number) ? value.toFixed() : parseInt(value.toString());
const _numDecoder = (type: string, value: any) => (value instanceof Number) ? value : parseFloat(value.toString());
const _dateDecoder = (type: string, value: any) => new Date(`${value}T00:00:00Z`);
const _dateTimeDecoder = (type: string, value: any) => new Date(value.toString());


export const deserializers: Record<string, EncoderFunc> = {
  'string': _stringDecoder,
  'String': _stringDecoder,
  'email': _stringDecoder,
  'uuid': _stringDecoder,
  'int': _intDecoder,
  'num': _numDecoder,
  'number': _numDecoder,
  'double': _numDecoder,
  'float': _numDecoder,
  'boolean': _passthroughDecoder,
  'object': _passthroughDecoder,
  'any': _passthroughDecoder,
  'Date': _dateDecoder,
  'DateTime': _dateTimeDecoder,
 {{#models}}
  {{#model}}
  '{{classname}}': (t, value) => {{classname}}TypeTransformer.fromJson(value),
  {{/model}}
{{/models}}
};


export class ObjectSerializer {
	public static deserializeOwn(value: any, innerType: string): any {
		const result: any = {};
		for (let __prop in value) {
			if (value.hasOwnProperty(__prop)) {
				result[__prop] = ObjectSerializer.deserialize(value[__prop], innerType);
			}
		}

    return result;
  }

	public static serializeOwn(value: any, innerType: string): any {
		const result: any = {};
		for (let __prop in value) {
			if (value.hasOwnProperty(__prop)) {
				result[__prop] = ObjectSerializer.serialize(value[__prop], innerType);
			}
		}

    return result;
	}

  public static serialize(value: any, targetType: string): any {
    if (value === null || value === undefined) {
      return undefined;
    }

    const encoder = serializers[targetType];
    if (encoder) {
      return encoder(targetType, value);
    }

    var match: any;
    if (((match = targetType.match(_regRecord)) !== null) && match.length === 2) {
      return ObjectSerializer.serializeOwn(value, match[1].trim());
    } else if ((value instanceof Array) &&
        ((match = targetType.match(_regList)) !== null) && match.length === 2) {
      return value.map((v) => ObjectSerializer.serialize(v, match[1]));
    } else if ((value instanceof Array) &&
        ((match = targetType.match(_regSet)) !== null) && match.length === 2) {
      return new Set(value.map((v) => ObjectSerializer.serialize(v, match[1])));
    } else if ((value instanceof Set) &&
    ((match = targetType.match(_regSet)) !== null) && match.length === 2) {
      return Array.from(value).map((v) => ObjectSerializer.serialize(v, match[1]));
    } else if (value instanceof Map && ((match = targetType.match(_regMap)) !== null) && match.length === 2) {
      return new Map(Array.from(value, ([k, v]) => [k, ObjectSerializer.serialize(v, match[1])]));
    }

    return undefined;
  }

  public static deserialize(value: any, targetType: string): any {
    if (value === null || value === undefined) return null; // 204
    if (targetType === null || targetType === undefined) return value.toString(); // best guess

    const decoder = deserializers[targetType];
    if (decoder) {
      return decoder(targetType, value);
    }

    var match: any;
    if (((match = targetType.match(_regRecord)) !== null) && match.length === 2) { // is an array we want an array
      return ObjectSerializer.deserializeOwn(value, match[1].trim());
    } else if ((value instanceof Array) &&
        ((match = targetType.match(_regList)) !== null) && match.length === 2) {
      return value.map((v) => ObjectSerializer.deserialize(v, match[1]));
    } else if ((value instanceof Array) && // is a array we want a set
        ((match = targetType.match(_regSet)) !== null) && match.length === 2) {
      return value.map((v) => ObjectSerializer.deserialize(v, match[1]));
    } else if ((value instanceof Set) && // is a set we want a set
        ((match = targetType.match(_regSet)) !== null) && match.length === 2) {
      return new Set(Array.from(value).map((v) => ObjectSerializer.deserialize(v, match[1])));
    } else if (value instanceof Map && ((match = targetType.match(_regMap)[1]) !== null) && match.length === 2) {
      return new Map(Array.from(value, ([k, v]) => [k, ObjectSerializer.deserialize(v, match[1])]));
    }

    return value;
  } // deserialize
} // end of serializer