{{#withSeparateModelsAndApi}}
  {{#x-ts-has-models}}
import { {{{x-ts-all-models}}} } from './';
  {{/x-ts-has-models}}

{{/withSeparateModelsAndApi}}
{{#models}}
{{#hasOneOf}}
  {{#model}}
class {{classname}}TypeTransformer {
  static toJson(val: {{classname}}): any {
    switch(val['{{{discriminator.propertyName}}}']) {
      {{#discriminator.mappedModels}}
      case '{{{mappingName}}}':
        return ObjectSerializer.serialize(val, '{{{modelName}}}');
      {{/discriminator.mappedModels}}
  {{#oneOf}}
      case '{{{.}}}':
        return ObjectSerializer.serialize(val, '{{{.}}}');
  {{/oneOf}}
      default:
        return val;
    }
  }

  static fromJson(val: any): {{classname}} {
    switch(val['{{{discriminator.propertyName}}}']) {
{{#discriminator.mappedModels}}
        case '{{{mappingName}}}':
          return ObjectSerializer.deserialize(val, '{{{modelName}}}');
{{/discriminator.mappedModels}}
      {{#oneOf}}
        case '{{{.}}}':
          return ObjectSerializer.deserialize(val, '{{{.}}}');
      {{/oneOf}}
      default:
        return val;
    }
  }
}
    {{/model}}
{{/hasOneOf}}
{{^hasOneOf}}
  {{#model}}
class {{classname}}TypeTransformer {
{{#additionalPropertiesType}}
  private static otherProperties = [{{#vars}}'{{{name}}}', {{/vars}}];
{{/additionalPropertiesType}}
  static toJson(val: {{classname}}): any {
{{#isEnum}}
    return val?.toString();
{{/isEnum}}
{{^isEnum}}
    const data: any = {};
    {{#vars}}
    if (val.{{{name}}}) {
    {{#vendorExtensions.x-ts-additional-props}}
      const p: any = {};
      for(let prop in val.{{{name}}}) {
        if (val.{{{name}}}.hasOwnProperty(prop)) {
          p[prop] = {{#vendorExtensions.x-ts-optimize}}val.{{{name}}}[prop]{{/vendorExtensions.x-ts-optimize}}{{^vendorExtensions.x-ts-optimize}}ObjectSerializer.serialize(val.{{{name}}}[prop], '{{{vendorExtensions.x-ts-additional-props}}}'){{/vendorExtensions.x-ts-optimize}};
        }
        data['{{{baseName}}}'] = p;
      }
    {{/vendorExtensions.x-ts-additional-props}}
    {{^vendorExtensions.x-ts-additional-props}}
      data['{{{baseName}}}'] = {{#vendorExtensions.x-ts-optimize}}val.{{{name}}}{{/vendorExtensions.x-ts-optimize}}{{^vendorExtensions.x-ts-optimize}}ObjectSerializer.serialize(val.{{{name}}}, '{{{vendorExtensions.x-ts-deserialize-type}}}'){{/vendorExtensions.x-ts-optimize}};
    {{/vendorExtensions.x-ts-additional-props}}
    }
    {{/vars}}
    {{#additionalPropertiesType}}
    for(let prop in val) {
      if ({{classname}}TypeTransformer.otherProperties.indexOf(prop) === -1 && val.hasOwnProperty(prop)) {
        data[prop] = {{#vendorExtensions.x-ts-optimize}}val[prop]{{/vendorExtensions.x-ts-optimize}}{{^vendorExtensions.x-ts-optimize}}ObjectSerializer.serialize(val[prop], '{{{additionalPropertiesType}}}'){{/vendorExtensions.x-ts-optimize}};
      }
    }
    {{/additionalPropertiesType}}
    return data;
{{/isEnum}}
  }

  // expect this to be a decoded value
  static fromJson(val: any): {{classname}} {
{{#isEnum}}
    if (val === null || val === undefined) return undefined;
    switch (val.toString()) {
    {{#allowableValues}}
      {{#enumVars}}
        case {{{value}}}:
          return {{classname}}.{{{name}}};
      {{/enumVars}}
    {{/allowableValues}}
    }

    return undefined;
{{/isEnum}}
{{^isEnum}}
    const init: any = {
    {{#vars}}
      {{^vendorExtensions.x-ts-additional-props}}
      {{name}}: {{#vendorExtensions.x-ts-optimize}}val['{{{baseName}}}']{{/vendorExtensions.x-ts-optimize}}{{^vendorExtensions.x-ts-optimize}}ObjectSerializer.deserialize(val['{{{baseName}}}'], '{{{vendorExtensions.x-ts-deserialize-type}}}'){{/vendorExtensions.x-ts-optimize}},
      {{/vendorExtensions.x-ts-additional-props}}
    {{/vars}}
    };
    {{#vars}}
    {{#vendorExtensions.x-ts-additional-props}}
    if (val['{{{baseName}}}']) {
      const data: any = {};
      const valData = val['{{{baseName}}}'];
      for(let prop in valData) {
        if (valData.hasOwnProperty(prop)) {
          data[prop] = {{#vendorExtensions.x-ts-optimize}}val[prop];{{/vendorExtensions.x-ts-optimize}}{{^vendorExtensions.x-ts-optimize}}ObjectSerializer.deserialize(valData[prop], '{{{vendorExtensions.x-ts-additional-props}}}');{{/vendorExtensions.x-ts-optimize}}
        }
      }
      init['{{{name}}}'] = data;
    }
    {{/vendorExtensions.x-ts-additional-props}}
    {{/vars}}
    {{#additionalPropertiesType}}
    for(let prop in val) {
      if ({{classname}}TypeTransformer.otherProperties.indexOf(prop) === -1 && val.hasOwnProperty(prop)) {
        init[prop] = {{#vendorExtensions.x-ts-optimize}}val[prop];{{/vendorExtensions.x-ts-optimize}}{{^vendorExtensions.x-ts-optimize}}ObjectSerializer.deserialize(val[prop], '{{{additionalPropertiesType}}}');{{/vendorExtensions.x-ts-optimize}}
      }
    }
    {{/additionalPropertiesType}}
    return new {{classname}}(init);
{{/isEnum}}
  }
}
  {{/model}}
{{/hasOneOf}}
{{/models}}


const _regList = new RegExp('^Array\\<(.*)\\>$');
const _regSet = new RegExp('^Set\\<(.*)\\>$');
const _regMap = new RegExp('^Map\\<string,(.*)\\>$');

const _baseEncoder = (type: string, value: any) => value;
const _dateEncoder = (type: string, value: any) => {
  const val = value as Date;
  return `${val.getFullYear()}-${val.getMonth()}-${val.getDay()}`;
};

export declare type EncoderFunc = (type: string, value: any) => any;

export const serializers: Record<string, EncoderFunc> = {
  'string': _baseEncoder,
  'String': _baseEncoder,
  'email': _baseEncoder,
  'uuid': _baseEncoder,
  'int': _baseEncoder,
  'num': _baseEncoder,
  'number': _baseEncoder,
  'double': _baseEncoder,
  'float': _baseEncoder,
  'boolean': _baseEncoder,
  'object': _baseEncoder,
  'any': _baseEncoder,
  'Array<string>': _baseEncoder,
  'Array<String>': _baseEncoder,
  'Array<email>': _baseEncoder,
  'Array<int>': _baseEncoder,
  'Array<num>': _baseEncoder,
  'Array<number>': _baseEncoder,
  'Array<double>': _baseEncoder,
  'Array<float>': _baseEncoder,
  'Array<boolean>': _baseEncoder,
  'Array<object>': _baseEncoder,
  'Array<any>': _baseEncoder, 
  'Set<string>': _baseEncoder,
  'Set<String>': _baseEncoder,
  'Set<email>': _baseEncoder,
  'Set<int>': _baseEncoder,
  'Set<num>': _baseEncoder,
  'Set<number>': _baseEncoder,
  'Set<double>': _baseEncoder,
  'Set<float>': _baseEncoder,
  'Set<boolean>': _baseEncoder,
  'Set<object>': _baseEncoder,
  'Set<any>': _baseEncoder,
  'Date': _dateEncoder,
  'DateTime': (t, value) => (value as Date).toISOString(),
 {{#models}}
  {{#model}}
  '{{classname}}': (t, value) => {{classname}}TypeTransformer.toJson(value),
  {{/model}}
{{/models}}
};

const _stringDecoder = (type: string, value: any) => value.toString();
const _passthroughDecoder = (type: string, value: any) => value;
const _intDecoder = (type: string, value: any) => (value instanceof Number) ? value.toFixed() : parseInt(value.toString());
const _numDecoder = (type: string, value: any) => (value instanceof Number) ? value : parseFloat(value.toString());
const _dateDecoder = (type: string, value: any) => new Date(`${value}T00:00:00Z`);
const _dateTimeDecoder = (type: string, value: any) => new Date(value.toString());


export const deserializers: Record<string, EncoderFunc> = {
  'string': _stringDecoder,
  'String': _stringDecoder,
  'email': _stringDecoder,
  'uuid': _stringDecoder,
  'int': _intDecoder,
  'num': _numDecoder,
  'number': _numDecoder,
  'double': _numDecoder,
  'float': _numDecoder,
  'boolean': _passthroughDecoder,
  'object': _passthroughDecoder,
  'any': _passthroughDecoder,
  'Date': _dateDecoder,
  'DateTime': _dateTimeDecoder,
 {{#models}}
  {{#model}}
  '{{classname}}': (t, value) => {{classname}}TypeTransformer.fromJson(value),
  {{/model}}
{{/models}}
};


export class ObjectSerializer {
  public static serialize(value: any, targetType: string): any {
    if (value === null || value === undefined) {
      return undefined;
    }

    const encoder = serializers[targetType];
    if (encoder) {
      return encoder(targetType, value);
    }

    var match: any;
    if ((value instanceof Array) &&
        ((match = targetType.match(_regList)[1]) !== undefined)) {
      return [...value.map((v) => ObjectSerializer.serialize(v, match))];
    } else if ((value instanceof Set) &&
    ((match = targetType.match(_regList)[1]) !== undefined)) {
      return [...Array.from(value).map((v) => ObjectSerializer.serialize(v, match))];
    } else if (value instanceof Map && ((match = targetType.match(_regMap)[1]) !== undefined)) {
      return new Map(Array.from(value, ([k, v]) => [k, ObjectSerializer.serialize(v, match)]));
    }

    return undefined;
  }

  public static deserialize(value: any, targetType: string): any {
    if (value === null || value === undefined) return null; // 204
    if (targetType === null || targetType === undefined) return value.toString(); // best guess

    const decoder = serializers[targetType];
    if (decoder) {
      return decoder(targetType, value);
    }

    var match: any;
    if ((value instanceof Array) &&
        ((match = targetType.match(_regList)[1]) !== undefined)) {
      return [...value.map((v) => ObjectSerializer.deserialize(v, match))];
    } else if ((value instanceof Set) &&
        ((match = targetType.match(_regList)[1]) !== undefined)) {
      return [...Array.from(value).map((v) => ObjectSerializer.deserialize(v, match))];
    } else if (value instanceof Map && ((match = targetType.match(_regMap)[1]) !== undefined)) {
      return new Map(Array.from(value, ([k, v]) => [k, ObjectSerializer.deserialize(v, match)]));
    }

    return value;
  } // deserialize
} // end of serializer