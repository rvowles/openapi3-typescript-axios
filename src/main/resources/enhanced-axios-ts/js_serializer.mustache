{{#withSeparateModelsAndApi}}
  {{#x-ts-has-models}}
import { {{{x-ts-all-models}}} } from './';
  {{/x-ts-has-models}}

{{/withSeparateModelsAndApi}}
{{#models}}
{{#hasOneOf}}
  {{#model}}
class {{classname}}TypeTransformer {
  static toJson(val: {{classname}}): any {
    switch(val['{{{discriminator.propertyName}}}']) {
      {{#discriminator.mappedModels}}
      case '{{{mappingName}}}':
        return ObjectSerializer.serialize(val, '{{{modelName}}}');
      {{/discriminator.mappedModels}}
  {{#oneOf}}
      case '{{{.}}}':
        return ObjectSerializer.serialize(val, '{{{.}}}');
  {{/oneOf}}
      default:
        return val;
    }
  }

  static fromJson(val: any): {{classname}} {
    switch(val['{{{discriminator.propertyName}}}']) {
{{#discriminator.mappedModels}}
        case '{{{mappingName}}}':
          return ObjectSerializer.deserialize(val, '{{{modelName}}}');
{{/discriminator.mappedModels}}
      {{#oneOf}}
        case '{{{.}}}':
          return ObjectSerializer.deserialize(val, '{{{.}}}');
      {{/oneOf}}
      default:
        return val;
    }
  }
}
    {{/model}}
{{/hasOneOf}}
{{^hasOneOf}}
  {{#model}}
class {{classname}}TypeTransformer {
{{#additionalPropertiesType}}
  private static otherProperties = [{{#vars}}'{{{name}}}', {{/vars}}];
{{/additionalPropertiesType}}
  static toJson(val: {{classname}}): any {
{{#isEnum}}
    return val?.toString();
{{/isEnum}}
{{^isEnum}}
    const data: any = {};
    {{#vars}}
    if (val.{{{name}}}) {
    {{#vendorExtensions.x-ts-additional-props}}
      const p = {};
      for(let prop in val.{{{name}}}) {
        if (val.{{{name}}}.hasOwnProperty(prop)) {
          p[prop] = ObjectSerializer.serialize(val.{{{name}}}[prop], '{{{vendorExtensions.x-ts-additional-props}}}');
        }
        data['{{{baseName}}}'] = p;
      }
    {{/vendorExtensions.x-ts-additional-props}}
    {{^vendorExtensions.x-ts-additional-props}}
      data['{{{baseName}}}'] = ObjectSerializer.serialize(val.{{{name}}}, '{{{vendorExtensions.x-ts-deserialize-type}}}');
    {{/vendorExtensions.x-ts-additional-props}}
    }
    {{/vars}}
    {{#additionalPropertiesType}}
    for(let prop in val) {
      if ({{classname}}TypeTransformer.otherProperties.indexOf(prop) === -1 && val.hasOwnProperty(prop)) {
        data[prop] = ObjectSerializer.serialize(val[prop], '{{{additionalPropertiesType}}}');
      }
    }
    {{/additionalPropertiesType}}
    return data;
{{/isEnum}}
  }

  // expect this to be a decoded value
  static fromJson(val: any): {{classname}} {
{{#isEnum}}
    if (val === null || val === undefined) return undefined;
    switch (val.toString()) {
    {{#allowableValues}}
      {{#enumVars}}
        case {{{value}}}:
          return {{classname}}.{{{name}}};
      {{/enumVars}}
    {{/allowableValues}}
    }

    return undefined;
{{/isEnum}}
{{^isEnum}}
    const init = {
    {{#vars}}
      {{^vendorExtensions.x-ts-additional-props}}
      {{name}}: ObjectSerializer.deserialize(val['{{{baseName}}}'], '{{{vendorExtensions.x-ts-deserialize-type}}}'),
      {{/vendorExtensions.x-ts-additional-props}}
    {{/vars}}
    };
    {{#vars}}
    {{#vendorExtensions.x-ts-additional-props}}
    if (val['{{{baseName}}}']) {
      const data = {};
      const valData = val['{{{baseName}}}'];
      for(let prop in valData) {
        if (valData.hasOwnProperty(prop)) {
          data[prop] = ObjectSerializer.serialize(valData[prop], '{{{vendorExtensions.x-ts-additional-props}}}');
        }
      }
      init['{{{name}}}'] = data;
    }
    {{/vendorExtensions.x-ts-additional-props}}
    {{/vars}}
    {{#additionalPropertiesType}}
    for(let prop in val) {
      if ({{classname}}TypeTransformer.otherProperties.indexOf(prop) === -1 && val.hasOwnProperty(prop)) {
        init[prop] = ObjectSerializer.deserialize(val[prop], '{{{additionalPropertiesType}}}');
      }
    }
    {{/additionalPropertiesType}}
    return new {{classname}}(init);
{{/isEnum}}
  }
}
  {{/model}}
{{/hasOneOf}}
{{/models}}


const _regList = new RegExp('^Array\\<(.*)\\>$');
const _regMap = new RegExp('^Map\\<string,(.*)\\>$');

// allow user to bolt in any kind of alternative deserialization, e.g. for uuids for similar
export interface ExternalSerializer {
  parseMatch(type: string, value: any): boolean;

  // will always be a value, not null or undefined
  parse(type: string, value: any): any;

  encodeMatch(type: string, value: any): boolean;

  // will always be a value, not null or undefined
  encode(type :string, value: any): any;
}

export class ObjectSerializer {
  public static extraSerializers: Array<ExternalSerializer> = [];
  public static serialize(value: any, targetType: string): any {
    if (value === null || value === undefined) {
      return undefined;
    }

    for(let val of ObjectSerializer.extraSerializers) {
      if (val.encodeMatch(targetType, value)) {
        return val.encode(targetType, value);
      }
    }

     switch (targetType) {
      case 'String':
      case 'string':
      case 'email':
      case 'uuid':
      case 'int':
      case 'num':
      case 'number':
      case 'double':
      case 'float':
      case 'boolean':
        return value;
      case 'object':
        return value;
      case 'Date':
        const val = value as Date;
        return `${val.getFullYear}-${val.getMonth()}-${val.getDay()}`;
      case 'DateTime':
        return (value as Date).toISOString();
{{#models}}
  {{#model}}
      case '{{classname}}':
        return {{classname}}TypeTransformer.toJson(value);
  {{/model}}
{{/models}}
      default:
        var match;
        if ((value instanceof Array) &&
            ((match = targetType.match(_regList)[1]) !== undefined)) {
          return [...value.map((v) => ObjectSerializer.serialize(v, match))];
        } else if (value instanceof Map && ((match = targetType.match(_regMap)[1]) !== undefined)) {
          return new Map(Array.from(value, ([k, v]) => [k, ObjectSerializer.serialize(v, match)]));
        }
    } // switch

    return undefined;
  }

  public static deserialize(value: any, targetType: string): any {
    if (value === null || value === undefined) return null; // 204
    if (targetType === null || value === undefined) return value.toString(); // best guess

    // let the externals have their go first
    for(let val of ObjectSerializer.extraSerializers) {
      if (val.parseMatch(targetType, value)) {
        return val.parse(targetType, value);
      }
    }

    switch (targetType) {
      case 'String':
      case 'string':
      case 'email':
      case 'uuid':
        return value.toString();
      case 'int':
         return value instanceof Number ? value : parseInt(value.toString());
      case 'num':
      case 'number':
      case 'double':
      case 'float':
        return value instanceof Number ? value : parseFloat(value.toString());
      case 'boolean':
        return value instanceof Boolean ? value : value.toString().toLowerCase() == 'true';
      case 'object':
        return value;
      case 'Date':
        return new Date(`${value}T00:00:00Z`);
      case 'DateTime':
        return new Date(value.toString());
{{#models}}
  {{#model}}
      case '{{classname}}':
        return {{classname}}TypeTransformer.fromJson(value);
  {{/model}}
{{/models}}
      default:
        var match;
        if ((value instanceof Array) &&
            ((match = targetType.match(_regList)[1]) !== undefined)) {
          return [...value.map((v) => ObjectSerializer.deserialize(v, match))];
        } else if (value instanceof Map && ((match = targetType.match(_regMap)[1]) !== undefined)) {
          return new Map(Array.from(value, ([k, v]) => [k, ObjectSerializer.deserialize(v, match)]));
        }
    } // switch

    return value;
  } // deserialize
} // end of serializer